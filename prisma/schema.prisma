generator client {
  provider  = "prisma-client-js"
  directUrl = env("DIRECT_URL")
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String             @id @default(cuid())
  email              String             @unique
  createdAt          DateTime           @default(now())
  comments           Comment[]          @relation("UserComments")
  notificationsActed Notification[]     @relation("NotificationActor")
  notifications      Notification[]
  notificationMutes  NotificationMute[]
  notificationPref   NotificationPref?
  profile            Profile?
}

model Profile {
  id                String               @id @default(cuid())
  userId            String               @unique
  handle            String               @unique
  displayName       String
  profession        String
  bio               String?              @db.VarChar(280)
  city              String?
  region            String?
  servicesEnabled   Boolean              @default(true)
  acceptsBriefs     Boolean              @default(false)
  acceptsDMs        Boolean              @default(true)
  showCityPublicly  Boolean              @default(true)
  showRatesPublicly Boolean              @default(false)
  currentWorkCity   String?
  currentWorkUntil  DateTime?
  verificationLevel VerificationLevel    @default(NONE)
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  avatarUrl         String?              @db.VarChar(500)
  accountType       AccountType          @default(PERSONAL)
  portfolioUrl      String?              @db.VarChar(500)
  professions       String[]             @default([])
  availability      AvailabilityWindow[]
  BriefTarget       BriefTarget[]
  links             ExternalLink[]
  following         Follow[]             @relation("follows_follower")
  followers         Follow[]             @relation("follows_following")
  posts             Post[]
  PostCollaborator  PostCollaborator[]
  user              User                 @relation(fields: [userId], references: [id])
  projectMembers    ProjectMember[]      @relation("ProfileMembers")
  Proposal          Proposal[]
  services          Service[]
  areas             ServiceArea[]
}

model Service {
  id          String  @id @default(cuid())
  profileId   String
  name        String
  priceMin    Int?
  priceMax    Int?
  currency    String  @default("CAD")
  unit        String
  description String? @db.VarChar(500)
  profile     Profile @relation(fields: [profileId], references: [id])
}

model ExternalLink {
  id        String  @id @default(cuid())
  profileId String
  type      String
  url       String
  profile   Profile @relation(fields: [profileId], references: [id])
}

model ServiceArea {
  id        String  @id @default(cuid())
  profileId String
  city      String
  region    String
  lat       Float
  lng       Float
  radiusKm  Float   @default(50)
  profile   Profile @relation(fields: [profileId], references: [id])
}

model AvailabilityWindow {
  id        String   @id @default(cuid())
  profileId String
  start     DateTime
  end       DateTime
  city      String?
  note      String?
  profile   Profile  @relation(fields: [profileId], references: [id])
}

model Post {
  id              String             @id @default(cuid())
  authorProfileId String
  caption         String?            @db.VarChar(1000)
  tags            String[]
  createdAt       DateTime           @default(now())
  externalUrl     String?            @db.VarChar(2048)
  location        String?            @db.VarChar(160)
  Comment         Comment[]
  likes           Like[]
  author          Profile            @relation(fields: [authorProfileId], references: [id])
  assets          PostAsset[]
  collaborators   PostCollaborator[]
}

model PostAsset {
  id            String  @id @default(cuid())
  postId        String
  url           String
  derivativeUrl String?
  order         Int     @default(0)
  altText       String?
  post          Post    @relation(fields: [postId], references: [id])
}

model PostCollaborator {
  postId    String
  profileId String
  role      String
  post      Post    @relation(fields: [postId], references: [id])
  profile   Profile @relation(fields: [profileId], references: [id])

  @@id([postId, profileId])
}

model Follow {
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  follower    Profile  @relation("follows_follower", fields: [followerId], references: [id])
  following   Profile  @relation("follows_following", fields: [followingId], references: [id])

  @@id([followerId, followingId])
}

model Like {
  userId    String
  postId    String
  createdAt DateTime @default(now())
  Post      Post     @relation(fields: [postId], references: [id])

  @@id([userId, postId])
}

model SavedList {
  id             String      @id @default(cuid())
  userId         String
  name           String
  createdAt      DateTime    @default(now())
  kind           SavedKind   @default(POSTS)
  seededProjects Project[]   @relation("SeedList")
  items          SavedItem[]
}

model SavedItem {
  id        String    @id @default(cuid())
  listId    String
  postId    String?
  profileId String?
  createdAt DateTime  @default(now())
  list      SavedList @relation(fields: [listId], references: [id])

  @@unique([listId, postId], map: "uniq_list_post")
  @@unique([listId, profileId], map: "uniq_list_profile")
}

model Thread {
  id             String    @id @default(cuid())
  participantIds String[]
  lastMessageAt  DateTime?
  messages       Message[]
}

model Message {
  id         String   @id @default(cuid())
  threadId   String
  fromUserId String
  text       String
  createdAt  DateTime @default(now())
  thread     Thread   @relation(fields: [threadId], references: [id])
}

model Brief {
  id              String        @id @default(cuid())
  createdByUserId String
  title           String
  description     String
  budgetMin       Int?
  budgetMax       Int?
  currency        String        @default("CAD")
  city            String?
  region          String?
  status          String        @default("open")
  createdAt       DateTime      @default(now())
  targets         BriefTarget[]
  proposals       Proposal[]
}

model BriefTarget {
  briefId   String
  profileId String
  invited   Boolean @default(false)
  brief     Brief   @relation(fields: [briefId], references: [id])
  profile   Profile @relation(fields: [profileId], references: [id])

  @@id([briefId, profileId])
}

model Proposal {
  id        String   @id @default(cuid())
  briefId   String
  profileId String
  message   String
  price     Int?
  currency  String   @default("CAD")
  status    String   @default("submitted")
  createdAt DateTime @default(now())
  brief     Brief    @relation(fields: [briefId], references: [id])
  profile   Profile  @relation(fields: [profileId], references: [id])
}

model Report {
  id             String   @id @default(cuid())
  reporterUserId String
  targetType     String
  targetId       String
  reason         String
  status         String   @default("open")
  createdAt      DateTime @default(now())
}

model Comment {
  id           String      @id @default(cuid())
  postId       String
  authorUserId String
  text         String?     @db.VarChar(1000)
  createdAt    DateTime    @default(now())
  kind         CommentKind @default(TEXT)
  stickerUrl   String?     @db.VarChar(2048)
  author       User        @relation("UserComments", fields: [authorUserId], references: [id])
  post         Post        @relation(fields: [postId], references: [id])

  @@index([postId, createdAt])
}

model Project {
  id             String               @id @default(cuid())
  ownerUserId    String
  name           String
  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt
  fromListId     String?
  shootDate      DateTime?
  crewCall       DateTime?
  shootCall      DateTime?
  details        Json?
  fromList       SavedList?           @relation("SeedList", fields: [fromListId], references: [id])
  members        ProjectMember[]
  callsheets     Callsheet[]
  coverUrl       String?
  // Back-relation to DashboardCallsheet
  dashboardLinks DashboardCallsheet[] @relation("ProjectDashboardLinks")

  @@index([ownerUserId])
}

model ProjectMember {
  id           String    @id @default(cuid())
  projectId    String
  profileId    String?
  externalName String?
  email        String?
  phone        String?
  department   String?
  role         String?
  callTime     DateTime?
  confirmed    Boolean   @default(false)
  notes        String?
  createdAt    DateTime  @default(now())
  profile      Profile?  @relation("ProfileMembers", fields: [profileId], references: [id])
  project      Project   @relation(fields: [projectId], references: [id])

  @@index([projectId])
  @@index([profileId])
}

model Notification {
  id          String            @id @default(cuid())
  userId      String
  type        NotificationType
  level       NotificationLevel @default(INFO)
  title       String?
  body        String?
  contextType String?
  contextId   String?
  isRead      Boolean           @default(false)
  createdAt   DateTime          @default(now())
  readAt      DateTime?
  actorUserId String?
  data        Json?
  actor       User?             @relation("NotificationActor", fields: [actorUserId], references: [id])
  user        User              @relation(fields: [userId], references: [id])

  @@index([userId, isRead, createdAt])
  @@index([contextType, contextId, userId])
}

model NotificationMute {
  userId      String
  contextType String
  contextId   String
  until       DateTime?
  user        User      @relation(fields: [userId], references: [id])

  @@id([userId, contextType, contextId])
  @@index([userId])
}

model NotificationPref {
  userId       String             @id
  emailEnabled Boolean            @default(true)
  quietStart   String?
  quietEnd     String?
  categories   Json?
  updatedAt    DateTime           @updatedAt
  digest       NotificationDigest @default(off)
  user         User               @relation(fields: [userId], references: [id])
}

enum CommentKind {
  TEXT
  STICKER
}

enum AccountType {
  PERSONAL
  COMPANY
}

enum VerificationLevel {
  NONE
  EMAIL
  DOMAIN
  BUSINESS_ID
}

enum SavedKind {
  POSTS
  PEOPLE
}

enum NotificationLevel {
  INFO
  ACTIONABLE
  CRITICAL
}

enum NotificationType {
  MESSAGE
  MENTION
  CALLSHEET_PUBLISHED
  CALLTIME_CHANGED
  SCHEDULE_UPDATED
  PROJECT
  SYSTEM
  FOLLOW
  COMMENT
  LIKE
}

enum NotificationDigest {
  off
  daily
  weekly
}

model Callsheet {
  id        String    @id @default(cuid())
  projectId String
  project   Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  day       Int?
  title     String?
  date      DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

// --- Dashboards -----------------------------

model Dashboard {
  id        String   @id @default(cuid())
  userId    String
  name      String
  slug      String   @unique
  coverUrl  String? // optional cover photo
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members    DashboardMember[]
  callsheets DashboardCallsheet[]

  @@index([userId])
}

model DashboardMember {
  id          String   @id @default(cuid())
  dashboardId String
  userId      String
  role        String   @default("OWNER")
  createdAt   DateTime @default(now())

  dashboard Dashboard @relation(fields: [dashboardId], references: [id])

  @@unique([dashboardId, userId])
  @@index([userId])
}

// Link dashboards to existing callsheets (your existing "Project" model)
model DashboardCallsheet {
  dashboardId String
  projectId   String
  linkedAt    DateTime @default(now())

  dashboard Dashboard @relation(fields: [dashboardId], references: [id])
  project   Project   @relation("ProjectDashboardLinks", fields: [projectId], references: [id])

  @@id([dashboardId, projectId])
}

model Opinion {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Kept server-side only, never exposed via API responses:
  authorUserId String // who posted (for moderation/abuse handling)

  // Content
  kind        OpinionKind // 'TEXT' | 'PHOTO' | 'POLL'
  text        String? // for TEXT or optional caption
  // If PHOTO: use an assets table or reuse your PostAsset model pattern:
  assets      OpinionAsset[]
  // If POLL
  pollOptions OpinionPollOption[]
  pollEndsAt  DateTime?

  // Engagement
  reactions OpinionReaction[]
  comments  OpinionComment[]
  votes     OpinionVote[] // for polls

  // Aggregates for ranking
  reactionCount Int   @default(0)
  commentCount  Int   @default(0)
  voteCount     Int   @default(0)
  scoreHot      Float @default(0) // long-lived engagement score
  scoreTrend    Float @default(0) // short-term momentum score

  // Moderation
  removed Boolean @default(false)
  reason  String?
}

enum OpinionKind {
  TEXT
  PHOTO
  POLL
}

model OpinionAsset {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  opinionId String
  url       String
  altText   String?
  order     Int      @default(0)
  opinion   Opinion  @relation(fields: [opinionId], references: [id], onDelete: Cascade)
}

model OpinionPollOption {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())
  opinionId   String
  label       String
  count       Int           @default(0) // denormalized for speed
  opinion     Opinion       @relation(fields: [opinionId], references: [id], onDelete: Cascade)
  OpinionVote OpinionVote[]
}

model OpinionVote {
  id          String             @id @default(cuid())
  createdAt   DateTime           @default(now())
  opinionId   String
  optionId    String?
  // Keep it anonymous publicly, but prevent duplicate voting:
  voterUserId String // or hash(IP+day) if you need anon even from admins
  opinion     Opinion            @relation(fields: [opinionId], references: [id], onDelete: Cascade)
  option      OpinionPollOption? @relation(fields: [optionId], references: [id])

  @@unique([opinionId, voterUserId]) // 1 vote per user
}

model OpinionReaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  opinionId String
  userId    String // for dedup; not exposed
  kind      String // 'like' | 'heart' etc (start with 'like')
  opinion   Opinion  @relation(fields: [opinionId], references: [id], onDelete: Cascade)

  @@unique([opinionId, userId, kind])
}

model OpinionComment {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  opinionId    String
  text         String
  // For moderation and self-delete you may keep authorUserId but never expose
  authorUserId String
  removed      Boolean  @default(false)
  opinion      Opinion  @relation(fields: [opinionId], references: [id], onDelete: Cascade)
}
